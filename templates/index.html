<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>The Galactic P2P Chatroom</title>

    <style>
        * { font-family:tahoma; font-size:12px; padding:0px; margin:0px; }
        p { line-height:18px; }
        div { width:500px; margin-left:auto; margin-right:auto;}
        #content { padding:5px; background:#ddd; border-radius:5px; overflow-y: scroll;
                   border:1px solid #CCC; margin-top:10px; height: 160px; }
        #input { border-radius:2px; border:1px solid #ccc;
                 margin-top:10px; padding:5px; width:400px;  }
        #status { width:88px; display:block; float:left; margin-top:15px; }
        #button { width:20px; display:block; float:right; margin-top:10px; }
        #userlist { width:100px; display:block; float:center; marigin-top:10px }
    </style>
    <script type="text/javascript" src="static/js/socket.io/socket.io.js"></script>
    <script>
        window.addEventListener('load', function () {

            // WebRTC
            var RTCSessionDescription = window.RTCSessionDescription;
            var RTCPeerConnection = window.webkitRTCPeerConnection;
            var RTCIceCandidate = window.RTCIceCandidate;

            var pc_config = {'iceServers': [{'url': 'stun:stun.l.google.com:19302'}]};
            var pc_constraints = {'optional': [{'DtlsSrtpKeyAgreement': true}]};
            
            var pc_send, pc_recieve;  // RTCPeerConnections
            var send_channel, receive_channel;  // RTCDataChannel

            // DOM elements
            var input = document.getElementById('input');
            var output = document.getElementById('content');
            var state = document.getElementById('status'); 
            var userlist = document.getElementById('userlist');

            // websocket connection to signaling server
            var socket = io(document.location.host, {'session': 'data'});

            // session details
            // username is stored in sessionStorage
            var available_peers = [];
            var user_name;
            var peer_name; 

            // syntactic sugar for array membership
            Array.prototype.includes = function(value){
                for (var i=0; i<=this.length; i++)
                    if (this[i] == value)
                        return true;
                return false;
            }


            /*
             * Add message to user output.
             * @param msg: string, text message to peer
             */
            function add_message(msg) {
                output.insertAdjacentHTML('afterbegin', "<p><span>" + msg + "</span></p>");
            }


            /*
             * Add user to user list.
             * @param user: string, username of user
             */
            function add_user(user) {
                console.log("Available peers: ", available_peers);
                if (!available_peers.includes(user)){
                    console.log("Adding user to user list", user);
                    available_peers.push(user);
                    userlist.add(new Option(user));
                }
            }


            /*
             * Remove user from user list.
             * @param user: string, username of user
             */
            function remove_user(user){
                for (var i=0; i <= available_peers.length; i++)
                    if (userlist[i].text == user)
                        userlist.remove(i)

                var index = available_peers.indexOf(user);
                available_peers.splice(index, 1);
                console.log("Available peers: ", available_peers);
            }
            

            /*
             * Set local session description and send the offer.
             * @param: desc, local session description
             */
            function setlocalsdp_createoffer(desc){
                console.log("Attempting to set local description.");
                pc_send.setLocalDescription(desc);
            }


            /*
             * Set remote description and send the answer.
             * @param: desc, remote sessions description
             */
            function setremotesdp_createanswer(desc){
                console.log("Attempting to set the remote description.");
                pc_recieve.setRemoteDescription(desc);
            }


            /*
             * Error message when creating offer.
             * @param: event, error that occured when creating offer
             */
            function createoffer_error(event){
                console.log('Error calling createOffer(...)', event.message);
            }


            /*
             * Handling ICE candidates for send channel.
             * @param: event
             */
            function send_handleicecandidate(event){
                console.log('send_handleicecandidate: event');
                if (event.candidate){
                    var candidate = event.candidate;
                    var message = {
                        is_sender: "true",
                        destination: peer_name,
                        sdpMid: candidate.sdpMid,
                        sdpMLineIndex: candidate.sdpMLineIndex,
                        candidate: candidate.candidate
                    }
                    socket.emit('ice candidate', message);
                } else {
                    console.log("End of ICE candidates.");
                }
            }


            function obtained_receive_channel() {
                console.log("Obtained data channel for receiving data.");
            }
            
            /*
             * caller setup communication channel with callee peer.
             * creates a new RTCPeerConnection object as well as the initial offer.
             * @param: (string) peer_name, name of peer to chat with
             */
            function start_sending_communication(peer_name){
                peer_name = peer_name;
                console.log("Attempting to setup peer communication with", peer_name);

                if (pc_send != null){
                    send_channel.close();
                    pc_send.close();
                    pc_send = null;
                }

                try{
                    pc_send = new RTCPeerConnection(null, {optional: []});
                    pc_send.onicecandidate = send_handleicecandidate;
                    try {
                        send_channel = pc_send.createDataChannel('sendchannel', {reliable: false});
                    } catch(e) {
                        console.log('Unable to create data channel.');
                        console.log('Send channel creation failed with exception:', e);
                        return;
                    }
                    console.log('created data channel');
                } catch(e) {
                    alert('Unable to create RTCPeerConnection.');
                    console.log('Peer creation failed with exception:', e.message);
                    return;
                }
                // create offer and set local description
                console.log('Successfully created send channel.');
                pc_send.createOffer().then(
                    // if successful, set the local description
                    setlocalsdp_createoffer
                ).then(function(){
                    // afterwards, send offer to signaling server
                    console.log('Sending offer to signaling server.'); 
                    var message = {
                        source: user_name,
                        destination: peer_name,
                        jsep: pc_send.localDescription
                    };
                    socket.emit('offer', message);
                }).catch(function(e){
                    console.log('Failed to create offer with error: ', e);
                });
             
            }

            /*
             * callee setup receiving channel with peer caller
             * @param: string, peer_name
             */
            function start_receiving_communication(peer_name){
                if (pc_receive != null){
                    receive_channel.close()
                    pc_receieve.close()
                    pc_receive = null;
                }

                try {
                    pc_receive = new RTCPeerConnection(null, {optional: []});
                    pc_receive.ondatachannel = obtained_recieve_channel;
                    pc_receive.onicecandidate = receive_handleicecandidate; 
                } catch(e) {
                    console.log("Unable to create pc_receive");
                }
                // create answer and set the remote description
                console.log("Successfully created pc_receve");
                pc_recieve.createAnswer().then(
                    setremotesdp_createanwer
                ).then(function(){
                    console.log("Sending answer to signaling server.");
                    var message = {
                       source: user_name,
                       destination: peer_name,
                       jsep: pc_recieve  
                    }
                    socket.emit('answer', message);
                }).catch(function(e){
                    console.log("Failed to create answer.");
                });
            }


            /*
             * connection/disconnection handlers
             */
            socket.on('connect', function(){
                console.log('connected to signaling server');
                input.removeAttribute('disabled');
                }).on('disconnect', function(){
                console.log('disconnected from signaling server');
                input.setAttribute('disabled', 'disabled');
            });


            /*
             * socket session handler 
             */
            socket.on('session', function(message){
                if (window.sessionStorage['token'] == undefined) {
                    var token = message.token;
                    window.sessionStorage.setItem('token', token);
                    user_name = token;
                    socket.emit('session', {
                        'token': message.token
                    });
                } else { 
                    var token = window.sessionStorage['token'];
                    user_name = token;
                    socket.emit('session', {
                        'token': token
                    });                   
                }                    
            });


            /*
             * handler for inital greeting message from server
             */
            socket.on('greeting', function(message){ 
                add_message(message);
            });


            socket.on('available peers', function(request){
                console.log("Received list of available peers:", request.available_peers);
                var peers = request.available_peers;
                for (var i = 0; i <= peers.length; i++)
                    add_user(peers[i]); 
            });


            socket.on('peer connected', function(message){
                console.log("New peer connected:", message);
                add_user(message.peer);
            });


            socket.on('peer disconnected', function(message){
                console.log("Peer disconnected:", message); 
                remove_user(message.peer);
            });

            /*
             * Handler for recieving offers from caller.
             */
            socket.on('offer', function(offer){
                 // check to-whom this offer is for, and route it to them
                 console.log("Received offer from", offer.source);
            });


            /*
             * Handler for recieving answers from callee.
             */
            socket.on('answer', function(answer){
            });
            
            window.beforeunload = function(){
                 socket.close();
            };


            input.onkeypress = function(e) {
		       if (e.keyCode == 13) {
                   var selected_user = userlist.selectedIndex;
                   if (selected_user != -1){
                       // create offer for selected user
                       peer_name = userlist[selected_user].text;
                       start_sending_communication(peer_name);
 
                       return false;
                   } else {
                       alert('Select a peer to connect with.');
                   }
               }
            };
        });
    </script>
    <body>
        <div id="content"></div>
        <div>
            <span id="status">welcome</span>
            <input type="text" id="input" disabled="disabled"/>
        </div>
        <select id="userlist" size=10> </select>
    </body>
</head>
</html>

